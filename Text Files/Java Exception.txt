An exception is an abnormal condition that arises in a code sequence at run time. In other words, an exception is a run-time error.
A Java exception is an object that describes an exceptional (that is, error) condition that has occurred in a piece of code.
When an exceptional condition arises, an object representing that exception is created and thrown in the method that caused the error.

Java exception handling is managed via five keywords: try, catch, throw, throws, and finally. Program statements that you want to
monitor for exceptions are contained within a try block. If an exception occurs within the try block, it is thrown.
Your code can catch this exception (using catch) and handle it in some rational manner. System-generated exceptions are automatically
thrown by the Java run-time system. To manually throw an exception, use the keyword throw. Any exception that is thrown out of a method
must be specified as such by a throws clause. Any code that must be executed after a try block completes is put in a finally block.


 EXCEPTION TYPES

All exception types are subclasses of the built-in class Throwable. Thus, Throwable is at the top of the exception class hierarchy.
Immediately below Throwable are two subclasses that partition exceptions into two distinct branches. One branch is headed by Exception.
This class is used for exceptional conditions that user programs should catch. This is also the class that you will subclass to
create your own custom exception types. There is an important subclass of Exception, called RuntimeException. Exceptions of this type
are automatically defined for the programs that you write and include things such as division by zero and invalid array indexing.

The other branch is topped by Error, which defines exceptions that are not expected to be caught under normal circumstances by your program.
Exceptions of type Error are used by the Java run-time system to indicate errors having to do with the run-time environment, itself.
Stack overflow is an example of such an error. This chapter will not be dealing with exceptions of type Error, because these are typically created
in response to catastrophic failures that cannot usually be handled by your program.

In the above example code, When the Java run-time system detects the attempt to divide by zero, it constructs a new exception object and then throws this exception.
This causes the execution of Demo to stop, because once an exception has been thrown, it must be caught by an exception handler and dealt with immediately.
In this example, we haven’t supplied any exception handlers of our own, so the exception is caught by the default handler provided by the Java run-time system.
Any exception that is not caught by your program will ultimately be processed by the default handler. The default handler displays a string describing the exception,
prints a stack trace from the point at which the exception occurred, and terminates the program.

Notice that the type of exception thrown is a subclass of Exception called ArithmeticException, which more specifically describes what type of error happened.
Java supplies several built-in exception types that match the various sorts of run-time errors that can be generated.


USING TRY AND CATCH

Although the default exception handler provided by the Java run-time system is useful for debugging, you will usually want to handle an exception yourself.
Doing so provides two benefits. First, it allows you to fix the error. Second, it prevents the program from automatically terminating.

To guard against and handle a run-time error, simply enclose the code that you want to monitor inside a try block.
Immediately following the try block, include a catch clause that specifies the exception type that you wish to catch.

The following program includes a try block and a catch clause that processes the ArithmeticException generated by the division-by-zero error:

Notice that the call to println( ) inside the try block is never executed. Once an exception is thrown, program control transfers out of the try block into the catch block.
Once the catch statement has executed, program control continues with the next line in the program following the entire try/catch mechanism.
A try and its catch statement form a unit. The scope of the catch clause is restricted to those statements specified by the immediately preceding try statement.
A catch statement cannot catch an exception thrown by another try statement (except in the case of nested try statements).

Case: try with multiple catch block....
So a try with multiple catch block is basically to indicate that if there are multiple exceptions or errors occurs in a program
then they can be tried with one try block and they can be caught with multiple catch block.

Another block that can be added with try-catch block i.e. finally so whatever exception whether occur or not finally block will always be executed.

Here exception doesn't occur and finally block executed.
Here exception occur but not handled and finally block executed.
Here exception occur as well as handled and finally block executed.

For each try block there can be zero or more catch blocks, but only one finally block.
The Finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort().


						CUSTOM EXCEPTION

Although Java’s built-in exceptions handle most common errors, you will probably want to create your own exception types to handle situations specific to your applications.
This is quite easy to do: just define a subclass of Exception. Your subclasses don’t need to actually implement anything - it is their existence in the type system that allows you to use them as exceptions.
The Exception class does not define any methods of its own. It does, of course, inherit those methods provided by Throwable.
Thus, all exceptions, including those that you create, have the methods defined by Throwable available to them.

Exception defines four constructors. Two were added by JDK 1.4 to support chained exceptions. The other two are:
Exception( )
Exception(String msg)

The first form creates an exception that has no description. The second form lets you specify a description of the exception.
Although specifying a description when an exception is created is often useful, sometimes it is better to override toString( ).
It's so because the version of toString( ) defined by Throwable (and inherited by Exception) first displays the name of the exception followed by a colon, 
which is then followed by your description. By overriding toString( ), you can prevent the exception name and colon from being displayed.
This makes for a cleaner output, which is desirable in some cases.
The following example declares a new subclass of Exception and then uses that subclass to signal an error condition in a method. It overrides the toString( ) method of Throwable class.

This example defines a subclass of Exception called MyException. This subclass is quite simple: it has only a constructor plus an overloaded toString( )
method that displays the value of the exception. The ExceptionDemo class defines a method named compute( ) that throws a MyException object.
The exception is thrown when compute( )’s integer parameter is greater than 10. The main( ) method sets up an exception handler for MyException, then
calls compute( ) with a legal value (less than 10) and an illegal one to show both paths through the code.